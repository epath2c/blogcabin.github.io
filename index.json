[{"content":"Question is here\nMy Study Note:\nI didn\u0026rsquo;t solve this problem at the first try, actually, I didn\u0026rsquo;t understand this problem at all because I was still confused about the data structuresingly linked list.\nThe approach I learned from this original solution\nvar mergeTwoLists = function(l1, l2) { let list = {value: null, next: null}; temp = list; while(l1 \u0026amp;\u0026amp; l2){ if(l1.val\u0026lt; l2.val){ temp.next = l1 l1= l1.next } else{ temp.next = l2 l2 = l2.next } temp = temp.next } temp.next = l1 || l2; return list.next }; When I first walked through this code, I\u0026rsquo;m so confused about the changing of temp can add items to the list\u0026rsquo;s next.\nIn this solution\u0026rsquo;s discussion, the comment from @gignupg helped me a lot. They said:\n While loop round 1:\nIn the if statement we say \u0026ldquo;crt.next = l2\u0026rdquo; which is the same as saying “mergedHead.next = l2” since “crt = mergedHead”.\nBut “crt” still equals “mergedHead” even though “mergedHead” itself now includes “mergedHead.next”.\nAfter the if statement we say “crt = crt.next”. Now “crt” does not equal “mergedHead” anymore. Instead it now equals “mergedHead.next”.\n Another Solution Using Recursion:\nSolution Here\nI copied the code here:\nvar mergeTwoLists = function(l1, l2) { if(!l1 || !l2) return (l1? l1:l2); if(l1.val \u0026lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } }; This solution is pretty good, too. Hope I can write code like these two one day. 😆\n","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/algotrithm2/","summary":"Question is here\nMy Study Note:\nI didn\u0026rsquo;t solve this problem at the first try, actually, I didn\u0026rsquo;t understand this problem at all because I was still confused about the data structuresingly linked list.\nThe approach I learned from this original solution\nvar mergeTwoLists = function(l1, l2) { let list = {value: null, next: null}; temp = list; while(l1 \u0026amp;\u0026amp; l2){ if(l1.val\u0026lt; l2.val){ temp.next = l1 l1= l1.next } else{ temp.","title":"Algorithm Practice 2 - Singly Linked List"},{"content":"This article is based on John Smilga\u0026rsquo;s JS project Grocery Bud.\nI summarize these steps to keep a reference of how to write full CRUD for my later study.\n Select all the needed elements (including get some pseudo ID) Start working on submitting form:(this eventListener callback function is written somewhere else, like, all the functions are written together so that we can manage the code more clearly.)  Three conditions:  What if we have value and the action is not edit What if we have value and the action is edit What if we don\u0026rsquo;t provide any value? In this case, we submit an empty string.   Firstly, the third conditon, because it is kinda simple. Just add an alert.  The alert should be reusable. So we need an extra function for the alert. Don\u0026rsquo;t forget to remove the alert.   Secondly, tackle the add item part.  Create element that can hold the value. Add attribute of data-id to this added item. REMEMBER render the item dynamically!   Add the added item to local storage  At least we need to have one store to keep the added data. After we add the data, we want to have a function to set the form to be default. For example, we want to set the placeholder to empty, etc.     Tackle the clear all button.  Clear the local storage. (At this point, it didn\u0026rsquo;t make much sense, because we havn\u0026rsquo;t actually set up our local store.) Set back to default set.   Tackle the delete action.  Note that the delete-one-item button is set dynamically in our JS, so we can\u0026rsquo;t select the specific button through DOM selector. There are two ways to do deletion and edit.  Or we can use element bubble to select the button\u0026rsquo;s parent element, in this case, the grocery-list element, and check to see whether we chose the delete button or edit button. Or we actually have access to this dynamically rendered item when we return that HTML in our if(value \u0026amp;\u0026amp; !editFlag) conditional condition. That\u0026rsquo;s where we can call the delete and edit function. Because we only have access to those elements in that if condition.  Why? In my opinion, after we add an item, this item element exists, and we add event listener after the item element was created, we can have access to the button inside the just-created element.\n    Some Notes:  If there is nothing left, hide the container. Set the alert.   Remove from the local store.(Havn\u0026rsquo;t created our store yet.)   Tackle the edit.  One trick: since you are editing the title, so choose the edit button\u0026rsquo;s container\u0026rsquo;s sibling element. In this case, is a paragraph with the item title. First step: get the origin data to the form handle the submit form.   Finally! The local data store! (Just use localStorage :no_mouth:)  set up the setItem, every time we edit or add something, we can use setItem method repeatedly. Every time we add, delete, edit something, we need to retrieve all the stored data. The retrieved data need to be changed from JSON to an array or object. Then iterate the data, find the one that need to be deleted or updated. Delete or update it. Then finally return the modified todolist and turn it to JSON.    Some problems that still confuse me:\n  Why use the complicate solution while writing the clearAll function?\n  When I wrote const before editElement, I couldn\u0026rsquo;t have access to editElement in my onsubmit function. Does that mean const can restrict this to lexiscope? :persevere:\n//This is a wrong answer!!! //The corrent one is to remove the const keyword in the third line. function editItem(e) { const item = e.currentTarget.parentElement.parentElement; const editElement = e.currentTarget.parentElement.previousElementSibling; console.log(editElement); input.value = editElement.innerHTML; ifEdit = true; editID = item.dataset.id; submitBtn.textContent = \u0026#34;edit\u0026#34;; }   ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/restfulpractice/","summary":"This article is based on John Smilga\u0026rsquo;s JS project Grocery Bud.\nI summarize these steps to keep a reference of how to write full CRUD for my later study.\n Select all the needed elements (including get some pseudo ID) Start working on submitting form:(this eventListener callback function is written somewhere else, like, all the functions are written together so that we can manage the code more clearly.)  Three conditions:  What if we have value and the action is not edit What if we have value and the action is edit What if we don\u0026rsquo;t provide any value?","title":"Steps of One Simple CRUD"},{"content":"格式参考 GitHub Pages action，可以根据自己需要，按照说明文档上的建议对上面的配置进一步调整。\n提交 commit，保存！之后会发现 action 在尝试运行，等待不到一分钟结果就会出来，变成绿色就说明成功啦！\n这时跑去公开仓库瞅瞅看，应该已经可以看到自动建了一个名为 gh-pages 的分支，里面出现了许多东西，此时打开你的博客域名应该已经可以看到博客内容啦！\n如果 github action 没成功跑起来也不要慌，点进 deploy 详细看下报错，一般都可以根据报错内容发现原因，对应去调整后再跑几遍即可。\n自定义域名注意事项 博客根目录下的 config 文件中 base url 更换为自定义域名 为自定义域名添加了 CNAME 记录（顶级域名也可添加四条 A 记录），详见 github 官方说明：Managing a custom domain for your GitHub Pages site 部署成功后，进入公开仓库 settings，pages 页面添加自定义域名，等待 DNS 检验成功 如果使用了 CDN（比如 cloudflare），github 上的强制 https 按钮可能不能点；cloudflare 免费提供 https 证书，如果无法正常显示 https，可以建立强制 https 规则 不适用 CDN 的情况下，github 已支持为自定义域名办法 let’s encrypt 证书，稍等一会儿即可生效 ✧ 部署完成后续管理\n","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/test/","summary":"格式参考 GitHub Pages action，可以根据自己需要，按照说明文档上的建议对上面的配置进一步调整。\n提交 commit，保存！之后会发现 action 在尝试运行，等待不到一分钟结果就会出来，变成绿色就说明成功啦！\n这时跑去公开仓库瞅瞅看，应该已经可以看到自动建了一个名为 gh-pages 的分支，里面出现了许多东西，此时打开你的博客域名应该已经可以看到博客内容啦！\n如果 github action 没成功跑起来也不要慌，点进 deploy 详细看下报错，一般都可以根据报错内容发现原因，对应去调整后再跑几遍即可。\n自定义域名注意事项 博客根目录下的 config 文件中 base url 更换为自定义域名 为自定义域名添加了 CNAME 记录（顶级域名也可添加四条 A 记录），详见 github 官方说明：Managing a custom domain for your GitHub Pages site 部署成功后，进入公开仓库 settings，pages 页面添加自定义域名，等待 DNS 检验成功 如果使用了 CDN（比如 cloudflare），github 上的强制 https 按钮可能不能点；cloudflare 免费提供 https 证书，如果无法正常显示 https，可以建立强制 https 规则 不适用 CDN 的情况下，github 已支持为自定义域名办法 let’s encrypt 证书，稍等一会儿即可生效 ✧ 部署完成后续管理","title":"Test"},{"content":"This article is based on the Scroll project here.\nIntro In CSS, the conainer height is set to 0 dy default, because we don\u0026rsquo;t wanna show the container when we first load the page. We want to use the toggle button to control whether to show it or not. That\u0026rsquo;s also how we use toggle method. In CSS, we set the style of class .show-links to be height of 200, so when we add this class by using event listener, we will see the links. The height is static, so when we add or remove one link, our style wouldn\u0026rsquo;t seem as nice as it was before.\n So we use Element.getBoundingClientRect()! In this project, each link\u0026rsquo;s height is 50px, so we need to dynamically set the link-container\u0026rsquo;s height to be the sum of all links:\ntoggleBtn.addEventListener(\u0026#34;click\u0026#34;, function () { const containerHeight = linksContainer.getBoundingClientRect().height; const linksHeight = links.getBoundingClientRect().height; if (containerHeight === 0) { linksContainer.style.height = `${linksHeight}px`; } else { linksContainer.style.height = 0; } });  Note: Even if the links have their own heights, we wouldn\u0026rsquo;t see the links with the link-container\u0026rsquo;s height being set to 0.\n ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/dynamicnavbar/","summary":"This article is based on the Scroll project here.\nIntro In CSS, the conainer height is set to 0 dy default, because we don\u0026rsquo;t wanna show the container when we first load the page. We want to use the toggle button to control whether to show it or not. That\u0026rsquo;s also how we use toggle method. In CSS, we set the style of class .show-links to be height of 200, so when we add this class by using event listener, we will see the links.","title":"How to make dynamic navbar?"},{"content":"1. Remove Duplicates from Sorted Array Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array/\nMy first solution:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return null; let i = 0; let j= i+1; let k = 0; while (j \u0026lt; nums.length){ while(nums[i] === nums[j]){ nums.splice(j, 1); k ++; } i ++; j ++; } }; Refactored version:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return 0; let i = 0; for(let j=1; j\u0026lt;nums.length; j ++) { if(nums[i] !== nums[j]){ i ++; nums[i] = nums[j] } } return i+1; };  My first solution takes more space and time to run. At the first time, I misunderstood the intention of this question. It says what exists after the uique values doesn\u0026rsquo;t matter, while I thought I need to return a \u0026lsquo;clean\u0026rsquo; array with only unique values. That\u0026rsquo;s why I chose the method of \u0026lsquo;splice\u0026rsquo;.\n 2. Two Sum Link: https://leetcode.com/problems/two-sum/\nMy first Solution:\nvar twoSum = function(nums, target) { let result = []; for(let i=0; i\u0026lt;nums.length -1; i++) { for(let j = i+1; j \u0026lt; nums.length; j++) { if(nums[i] + nums[j] === target) { result[0] = i; result[1] = j; return result } } } }; Refactored version:\nvar twoSum = function(nums, target) { let map = new Map(); for(let i =0; i\u0026lt;nums.length; i++){ let diff = target - nums[i]; if (map.get(nums[i]) === undefined){ map.set(diff, i) } else { return [map.get(nums[i]),i] } } };  This one is pretty important. I know my first reaction of using a nested loop is definitely not a good idea. That will make time complexity 0(n^2). I searched other people\u0026rsquo;s solution, and find that this one need to take advantage of hash table. In this case, JS\u0026rsquo;s built-in hash table data structure - Map, comes in handy.\nUnder this question\u0026rsquo;s assumption,To get the target number, an item has only one number that can be added to it. So if we store the needed number and store them in a hash table, every time we get to next number, we can check if this number is in the hash table, and if not, we can calculate the second number and store that one in the map. Until at some point, we find the needed number in the map.\nThis way, the time complexity is O(n).\n 3. Roman to Integer Link: https://leetcode.com/problems/roman-to-integer/\nMy first solution:\nvar romanToInt = function(s) { const pattern = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; const rule = { V: \u0026#34;I\u0026#34;, X: \u0026#34;I\u0026#34;, L: \u0026#34;X\u0026#34;, C: \u0026#34;X\u0026#34;, D: \u0026#34;C\u0026#34;, M: \u0026#34;C\u0026#34; }; let currentSum = 0; let oneNumber = 0; let i = s.length - 1; let j = i - 1; while (j \u0026gt;= -1){ if(rule[s[i]] \u0026amp;\u0026amp; rule[s[i]] === s[j]){ oneNumber = pattern[s[i]] - pattern[s[j]] currentSum = currentSum + oneNumber i = i - 2; j = j - 2; } else { oneNumber = pattern[s[i]] currentSum = currentSum + oneNumber; i = i - 1; j = j - 1; } } return currentSum; }; Refactor version:\nvar romanToInt = function(s) { const pattern = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; let sum = 0; for(let i =0; i\u0026lt;s.length; i++){ let current = pattern[s[i]] let next = pattern[s[i+1]] if(current \u0026lt; next){ sum = sum - current } else { sum = sum + current } } return sum };  It\u0026rsquo;s more like a mathematical trick. For DXC, you needn\u0026rsquo;t treat XC as a unit. You can first subtract the X and then add the C if X is less than C.\nI think this solution is quite smart. Salute to whoever comes up with this solution!\n ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/algorithm1/","summary":"1. Remove Duplicates from Sorted Array Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array/\nMy first solution:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return null; let i = 0; let j= i+1; let k = 0; while (j \u0026lt; nums.length){ while(nums[i] === nums[j]){ nums.splice(j, 1); k ++; } i ++; j ++; } }; Refactored version:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return 0; let i = 0; for(let j=1; j\u0026lt;nums.length; j ++) { if(nums[i] !","title":"Algorithm Practice 1"},{"content":" Here is the summary of some tricks from John Smilga\u0026rsquo;s JS projects. This post is depending on \u0026lsquo;Menu\u0026rsquo;.\n INTRO: While building simple project, it seems ok to hard-code some elements, like the buttons here. But in the real world, it would be better to dynamically render buttons due to the data we fetched from some database.    Use vanilla JS to load content when the DOM was first rendered.\nRemember the usage of window.addEnventListener and DOMContentLoaded.\nBy using these two methods, we can load the given data to the DOM through JS.\n//menu is an given array of a bunch of objects.  const sectionCenter = document.querySelector(\u0026#34;.section-center\u0026#34;); window.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function () { renderedMenu(menu) }); function renderedMenu(renderedMenu) { let displayMenu = renderedMenu.map(function (item) { return `Write the HTML that we need to render here, and concat them using join`; }); displayMenu = displayMenu.join(\u0026#34;\u0026#34;); //This display Menu is an array, so when we use method \u0026#34;join\u0026#34;, we can concatenate all the values.  //Note that if we don\u0026#39;t use an empty string, we will concat the returned values with comas among them.  sectionCenter.innerHTML = displayMenu; //sectionCenter is the parent element of all the menu items.  }   If we want to add buttons to filter all the items, we probably want to show different buttons due to different kinds, in this scenario, menu\u0026rsquo;s categories. Bacause the category\u0026rsquo;s amount will change some day, rendering some static buttons in the first place is not enough.\nfunction renderedBtn() { // First, fetch all the unique categories and put them into an array.  const categories = menu.reduce( function (values, item) { if (!values.includes(item.category)) { values.push(item.category); } return values; }, [\u0026#34;all\u0026#34;] ); // Second, build unique buttons for those categories.  const categoryBtn = categories .map(function (category) { return `\u0026lt;button class=\u0026#34;filter-btn\u0026#34; data-id=${category}\u0026gt;${category}\u0026lt;/button\u0026gt;`; }) .join(\u0026#34;\u0026#34;); btnContainer.innerHTML = categoryBtn; const btns = document.querySelectorAll(\u0026#34;.filter-btn\u0026#34;); // Third, for each button, add an event listener \u0026#39;click\u0026#39; to filter all the items.  btns.forEach(function (btn) { btn.addEventListener(\u0026#34;click\u0026#34;, function (e) { const id = e.currentTarget.dataset.id; const filteredItem = menu.filter(function (menuItem) { if (id === menuItem.category) { return menuItem; } }); if (id === \u0026#34;all\u0026#34;) { renderedMenu(menu); } else { renderedMenu(filteredItem); } }); }); }     Remember the use of JS method \u0026lsquo;reduce\u0026rsquo;, it receive a callback function. Its an pretty useful filter function.\n  Use dataset to add additional info to an element.\n  ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/dynamichtmlbyjs/","summary":"Here is the summary of some tricks from John Smilga\u0026rsquo;s JS projects. This post is depending on \u0026lsquo;Menu\u0026rsquo;.\n INTRO: While building simple project, it seems ok to hard-code some elements, like the buttons here. But in the real world, it would be better to dynamically render buttons due to the data we fetched from some database.    Use vanilla JS to load content when the DOM was first rendered.","title":"How to build dynamic HTML elements with vanilla JS?"}]