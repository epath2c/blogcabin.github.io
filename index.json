[{"content":"This article is based on the Scroll project here.\nIntro In CSS, the conainer height is set to 0 dy default, because we don\u0026rsquo;t wanna show the container when we first load the page. We want to use the toggle button to control whether to show it or not. That\u0026rsquo;s also how we use toggle method. In CSS, we set the style of class .show-links to be height of 200, so when we add this class by using event listener, we will see the links. The height is static, so when we add or remove one link, our style wouldn\u0026rsquo;t seem as nice as it was before.\n So we use Element.getBoundingClientRect()! In this project, each link\u0026rsquo;s height is 50px, so we need to dynamically set the link-container\u0026rsquo;s height to be the sum of all links:\ntoggleBtn.addEventListener(\u0026#34;click\u0026#34;, function () { const containerHeight = linksContainer.getBoundingClientRect().height; const linksHeight = links.getBoundingClientRect().height; if (containerHeight === 0) { linksContainer.style.height = `${linksHeight}px`; } else { linksContainer.style.height = 0; } });  Note: Even if the links have their own heights, we wouldn\u0026rsquo;t see the links with the link-container\u0026rsquo;s height being set to 0.\n ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/dynamicnavbar/","summary":"This article is based on the Scroll project here.\nIntro In CSS, the conainer height is set to 0 dy default, because we don\u0026rsquo;t wanna show the container when we first load the page. We want to use the toggle button to control whether to show it or not. That\u0026rsquo;s also how we use toggle method. In CSS, we set the style of class .show-links to be height of 200, so when we add this class by using event listener, we will see the links.","title":"How to make dynamic navbar?"},{"content":"1. Remove Duplicates from Sorted Array Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array/\nMy first solution:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return null; let i = 0; let j= i+1; let k = 0; while (j \u0026lt; nums.length){ while(nums[i] === nums[j]){ nums.splice(j, 1); k ++; } i ++; j ++; } }; Refactored version:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return 0; let i = 0; for(let j=1; j\u0026lt;nums.length; j ++) { if(nums[i] !== nums[j]){ i ++; nums[i] = nums[j] } } return i+1; };  My first solution takes more space and time to run. At the first time, I misunderstood the intention of this question. It says what exists after the uique values doesn\u0026rsquo;t matter, while I thought I need to return a \u0026lsquo;clean\u0026rsquo; array with only unique values. That\u0026rsquo;s why I chose the method of \u0026lsquo;splice\u0026rsquo;.\n 2. Two Sum Link: https://leetcode.com/problems/two-sum/\nMy first Solution:\nvar twoSum = function(nums, target) { let result = []; for(let i=0; i\u0026lt;nums.length -1; i++) { for(let j = i+1; j \u0026lt; nums.length; j++) { if(nums[i] + nums[j] === target) { result[0] = i; result[1] = j; return result } } } }; Refactored version:\nvar twoSum = function(nums, target) { let map = new Map(); for(let i =0; i\u0026lt;nums.length; i++){ let diff = target - nums[i]; if (map.get(nums[i]) === undefined){ map.set(diff, i) } else { return [map.get(nums[i]),i] } } };  This one is pretty important. I know my first reaction of using a nested loop is definitely not a good idea. That will make time complexity 0(n^2). I searched other people\u0026rsquo;s solution, and find that this one need to take advantage of hash table. In this case, JS\u0026rsquo;s built-in hash table data structure - Map, comes in handy.\nUnder this question\u0026rsquo;s assumption,To get the target number, an item has only one number that can be added to it. So if we store the needed number and store them in a hash table, every time we get to next number, we can check if this number is in the hash table, and if not, we can calculate the second number and store that one in the map. Until at some point, we find the needed number in the map.\nThis way, the time complexity is O(n).\n 3. Roman to Integer Link: https://leetcode.com/problems/roman-to-integer/\nMy first solution:\nvar romanToInt = function(s) { const pattern = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; const rule = { V: \u0026#34;I\u0026#34;, X: \u0026#34;I\u0026#34;, L: \u0026#34;X\u0026#34;, C: \u0026#34;X\u0026#34;, D: \u0026#34;C\u0026#34;, M: \u0026#34;C\u0026#34; }; let currentSum = 0; let oneNumber = 0; let i = s.length - 1; let j = i - 1; while (j \u0026gt;= -1){ if(rule[s[i]] \u0026amp;\u0026amp; rule[s[i]] === s[j]){ oneNumber = pattern[s[i]] - pattern[s[j]] currentSum = currentSum + oneNumber i = i - 2; j = j - 2; } else { oneNumber = pattern[s[i]] currentSum = currentSum + oneNumber; i = i - 1; j = j - 1; } } return currentSum; }; Refactor version:\nvar romanToInt = function(s) { const pattern = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; let sum = 0; for(let i =0; i\u0026lt;s.length; i++){ let current = pattern[s[i]] let next = pattern[s[i+1]] if(current \u0026lt; next){ sum = sum - current } else { sum = sum + current } } return sum };  It\u0026rsquo;s more like a mathematical trick. For DXC, you needn\u0026rsquo;t treat XC as a unit. You can first subtract the X and then add the C if X is less than C.\nI think this solution is quite smart. Salute to whoever comes up with this solution!\n ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/algorithm1/","summary":"1. Remove Duplicates from Sorted Array Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array/\nMy first solution:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return null; let i = 0; let j= i+1; let k = 0; while (j \u0026lt; nums.length){ while(nums[i] === nums[j]){ nums.splice(j, 1); k ++; } i ++; j ++; } }; Refactored version:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return 0; let i = 0; for(let j=1; j\u0026lt;nums.length; j ++) { if(nums[i] !","title":"Algorithm Practice 1"},{"content":" Here is the summary of some tricks from John Smilga\u0026rsquo;s JS projects. This post is depending on \u0026lsquo;Menu\u0026rsquo;.\n INTRO: While building simple project, it seems ok to hard-code some elements, like the buttons here. But in the real world, it would be better to dynamically render buttons due to the data we fetched from some database.    Use vanilla JS to load content when the DOM was first rendered.\nRemember the usage of window.addEnventListener and DOMContentLoaded.\nBy using these two methods, we can load the given data to the DOM through JS.\n//menu is an given array of a bunch of objects.  const sectionCenter = document.querySelector(\u0026#34;.section-center\u0026#34;); window.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function () { renderedMenu(menu) }); function renderedMenu(renderedMenu) { let displayMenu = renderedMenu.map(function (item) { return `Write the HTML that we need to render here, and concat them using join`; }); displayMenu = displayMenu.join(\u0026#34;\u0026#34;); //This display Menu is an array, so when we use method \u0026#34;join\u0026#34;, we can concatenate all the values.  //Note that if we don\u0026#39;t use an empty string, we will concat the returned values with comas among them.  sectionCenter.innerHTML = displayMenu; //sectionCenter is the parent element of all the menu items.  }   If we want to add buttons to filter all the items, we probably want to show different buttons due to different kinds, in this scenario, menu\u0026rsquo;s categories. Bacause the category\u0026rsquo;s amount will change some day, rendering some static buttons in the first place is not enough.\nfunction renderedBtn() { // First, fetch all the unique categories and put them into an array.  const categories = menu.reduce( function (values, item) { if (!values.includes(item.category)) { values.push(item.category); } return values; }, [\u0026#34;all\u0026#34;] ); // Second, build unique buttons for those categories.  const categoryBtn = categories .map(function (category) { return `\u0026lt;button class=\u0026#34;filter-btn\u0026#34; data-id=${category}\u0026gt;${category}\u0026lt;/button\u0026gt;`; }) .join(\u0026#34;\u0026#34;); btnContainer.innerHTML = categoryBtn; const btns = document.querySelectorAll(\u0026#34;.filter-btn\u0026#34;); // Third, for each button, add an event listener \u0026#39;click\u0026#39; to filter all the items.  btns.forEach(function (btn) { btn.addEventListener(\u0026#34;click\u0026#34;, function (e) { const id = e.currentTarget.dataset.id; const filteredItem = menu.filter(function (menuItem) { if (id === menuItem.category) { return menuItem; } }); if (id === \u0026#34;all\u0026#34;) { renderedMenu(menu); } else { renderedMenu(filteredItem); } }); }); }     Remember the use of JS method \u0026lsquo;reduce\u0026rsquo;, it receive a callback function. Its an pretty useful filter function.\n  Use dataset to add additional info to an element.\n  ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/dynamichtmlbyjs/","summary":"Here is the summary of some tricks from John Smilga\u0026rsquo;s JS projects. This post is depending on \u0026lsquo;Menu\u0026rsquo;.\n INTRO: While building simple project, it seems ok to hard-code some elements, like the buttons here. But in the real world, it would be better to dynamically render buttons due to the data we fetched from some database.    Use vanilla JS to load content when the DOM was first rendered.","title":"How to build dynamic HTML elements with vanilla JS?"}]