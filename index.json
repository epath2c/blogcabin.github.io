[{"content":" Here is the summary of some tricks from John Smilga\u0026rsquo;s JS projects. This post is depending on \u0026lsquo;Menu\u0026rsquo;.\n INTRO: While building simple project, it seems ok to hard-code some elements, like the buttons here. But in the real world, it would be better to dynamically render buttons due to the data we fetched from some database.    Use vanilla JS to load content when the DOM was first rendered.\nRemember the usage of window.addEnventListener and DOMContentLoaded.\nBy using these two methods, we can load the given data to the DOM through JS.\n//menu is an given array of a bunch of objects.  const sectionCenter = document.querySelector(\u0026#34;.section-center\u0026#34;); window.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function () { renderedMenu(menu) }); function renderedMenu(renderedMenu) { let displayMenu = renderedMenu.map(function (item) { return `Write the HTML that we need to render here, and concat them using join`; }); displayMenu = displayMenu.join(\u0026#34;\u0026#34;); //This display Menu is an array, so when we use method \u0026#34;join\u0026#34;, we can concatenate all the values.  //Note that if we don\u0026#39;t use an empty string, we will concat the returned values with comas among them.  sectionCenter.innerHTML = displayMenu; //sectionCenter is the parent element of all the menu items.  }   If we want to add buttons to filter all the items, we probably want to show different buttons due to different kinds, in this scenario, menu\u0026rsquo;s categories. Bacause the category\u0026rsquo;s amount will change some day, rendering some static buttons in the first place is not enough.\nfunction renderedBtn() { // First, fetch all the unique categories and put them into an array.  const categories = menu.reduce( function (values, item) { if (!values.includes(item.category)) { values.push(item.category); } return values; }, [\u0026#34;all\u0026#34;] ); // Second, build unique buttons for those categories.  const categoryBtn = categories .map(function (category) { return `\u0026lt;button class=\u0026#34;filter-btn\u0026#34; data-id=${category}\u0026gt;${category}\u0026lt;/button\u0026gt;`; }) .join(\u0026#34;\u0026#34;); btnContainer.innerHTML = categoryBtn; const btns = document.querySelectorAll(\u0026#34;.filter-btn\u0026#34;); // Third, for each button, add an event listener \u0026#39;click\u0026#39; to filter all the items.  btns.forEach(function (btn) { btn.addEventListener(\u0026#34;click\u0026#34;, function (e) { const id = e.currentTarget.dataset.id; const filteredItem = menu.filter(function (menuItem) { if (id === menuItem.category) { return menuItem; } }); if (id === \u0026#34;all\u0026#34;) { renderedMenu(menu); } else { renderedMenu(filteredItem); } }); }); }     Remember the use of JS method \u0026lsquo;reduce\u0026rsquo;, it receive a callback function. Its an pretty useful filter function.\n  Use dataset to add additional info to an element.\n  ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/dynamichtmlbyjs/","summary":"Here is the summary of some tricks from John Smilga\u0026rsquo;s JS projects. This post is depending on \u0026lsquo;Menu\u0026rsquo;.\n INTRO: While building simple project, it seems ok to hard-code some elements, like the buttons here. But in the real world, it would be better to dynamically render buttons due to the data we fetched from some database.    Use vanilla JS to load content when the DOM was first rendered.","title":"How to build dynamic HTML elements with vanilla JS?"}]