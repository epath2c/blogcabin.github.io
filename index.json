[{"content":"Question is here\nMy Study Note:\nI didn\u0026rsquo;t solve this problem at the first try, actually, I didn\u0026rsquo;t understand this problem at all because I was still confused about the data structuresingly linked list.\nThe approach I learned from this original solution\nvar mergeTwoLists = function(l1, l2) { let list = {value: null, next: null}; temp = list; while(l1 \u0026amp;\u0026amp; l2){ if(l1.val\u0026lt; l2.val){ temp.next = l1 l1= l1.next } else{ temp.next = l2 l2 = l2.next } temp = temp.next } temp.next = l1 || l2; return list.next }; When I first walked through this code, I\u0026rsquo;m so confused about the changing of temp can add items to the list\u0026rsquo;s next.\nIn this solution\u0026rsquo;s discussion, the comment from @gignupg helped me a lot. They said:\n While loop round 1:\nIn the if statement we say \u0026ldquo;crt.next = l2\u0026rdquo; which is the same as saying â€œmergedHead.next = l2â€ since â€œcrt = mergedHeadâ€.\nBut â€œcrtâ€ still equals â€œmergedHeadâ€ even though â€œmergedHeadâ€ itself now includes â€œmergedHead.nextâ€.\nAfter the if statement we say â€œcrt = crt.nextâ€. Now â€œcrtâ€ does not equal â€œmergedHeadâ€ anymore. Instead it now equals â€œmergedHead.nextâ€.\n Another Solution Using Recursion:\nSolution Here\nI copied the code here:\nvar mergeTwoLists = function(l1, l2) { if(!l1 || !l2) return (l1? l1:l2); if(l1.val \u0026lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } }; This solution is pretty good, too. Hope I can write code like these two one day. ğŸ˜†\n","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/algotrithm2/","summary":"Question is here\nMy Study Note:\nI didn\u0026rsquo;t solve this problem at the first try, actually, I didn\u0026rsquo;t understand this problem at all because I was still confused about the data structuresingly linked list.\nThe approach I learned from this original solution\nvar mergeTwoLists = function(l1, l2) { let list = {value: null, next: null}; temp = list; while(l1 \u0026amp;\u0026amp; l2){ if(l1.val\u0026lt; l2.val){ temp.next = l1 l1= l1.next } else{ temp.","title":"Algorithm Practice 2 - Singly Linked List"},{"content":"This article is based on John Smilga\u0026rsquo;s JS project Grocery Bud.\nI summarize these steps to keep a reference of how to write full CRUD for my later study.\n Select all the needed elements (including get some pseudo ID) Start working on submitting form:(this eventListener callback function is written somewhere else, like, all the functions are written together so that we can manage the code more clearly.)  Three conditions:  What if we have value and the action is not edit What if we have value and the action is edit What if we don\u0026rsquo;t provide any value? In this case, we submit an empty string.   Firstly, the third conditon, because it is kinda simple. Just add an alert.  The alert should be reusable. So we need an extra function for the alert. Don\u0026rsquo;t forget to remove the alert.   Secondly, tackle the add item part.  Create element that can hold the value. Add attribute of data-id to this added item. REMEMBER render the item dynamically!   Add the added item to local storage  At least we need to have one store to keep the added data. After we add the data, we want to have a function to set the form to be default. For example, we want to set the placeholder to empty, etc.     Tackle the clear all button.  Clear the local storage. (At this point, it didn\u0026rsquo;t make much sense, because we havn\u0026rsquo;t actually set up our local store.) Set back to default set.   Tackle the delete action.  Note that the delete-one-item button is set dynamically in our JS, so we can\u0026rsquo;t select the specific button through DOM selector. There are two ways to do deletion and edit.  Or we can use element bubble to select the button\u0026rsquo;s parent element, in this case, the grocery-list element, and check to see whether we chose the delete button or edit button. Or we actually have access to this dynamically rendered item when we return that HTML in our if(value \u0026amp;\u0026amp; !editFlag) conditional condition. That\u0026rsquo;s where we can call the delete and edit function. Because we only have access to those elements in that if condition.  Why? In my opinion, after we add an item, this item element exists, and we add event listener after the item element was created, we can have access to the button inside the just-created element.\n    Some Notes:  If there is nothing left, hide the container. Set the alert.   Remove from the local store.(Havn\u0026rsquo;t created our store yet.)   Tackle the edit.  One trick: since you are editing the title, so choose the edit button\u0026rsquo;s container\u0026rsquo;s sibling element. In this case, is a paragraph with the item title. First step: get the origin data to the form handle the submit form.   Finally! The local data store! (Just use localStorage :no_mouth:)  set up the setItem, every time we edit or add something, we can use setItem method repeatedly. Every time we add, delete, edit something, we need to retrieve all the stored data. The retrieved data need to be changed from JSON to an array or object. Then iterate the data, find the one that need to be deleted or updated. Delete or update it. Then finally return the modified todolist and turn it to JSON.    Some problems that still confuse me:\n  Why use the complicate solution while writing the clearAll function?\n  When I wrote const before editElement, I couldn\u0026rsquo;t have access to editElement in my onsubmit function. Does that mean const can restrict this to lexiscope? :persevere:\n//This is a wrong answer!!! //The corrent one is to remove the const keyword in the third line. function editItem(e) { const item = e.currentTarget.parentElement.parentElement; const editElement = e.currentTarget.parentElement.previousElementSibling; console.log(editElement); input.value = editElement.innerHTML; ifEdit = true; editID = item.dataset.id; submitBtn.textContent = \u0026#34;edit\u0026#34;; }   ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/restfulpractice/","summary":"This article is based on John Smilga\u0026rsquo;s JS project Grocery Bud.\nI summarize these steps to keep a reference of how to write full CRUD for my later study.\n Select all the needed elements (including get some pseudo ID) Start working on submitting form:(this eventListener callback function is written somewhere else, like, all the functions are written together so that we can manage the code more clearly.)  Three conditions:  What if we have value and the action is not edit What if we have value and the action is edit What if we don\u0026rsquo;t provide any value?","title":"Steps of One Simple CRUD"},{"content":"æ ¼å¼å‚è€ƒ GitHub Pages actionï¼Œå¯ä»¥æ ¹æ®è‡ªå·±éœ€è¦ï¼ŒæŒ‰ç…§è¯´æ˜æ–‡æ¡£ä¸Šçš„å»ºè®®å¯¹ä¸Šé¢çš„é…ç½®è¿›ä¸€æ­¥è°ƒæ•´ã€‚\næäº¤ commitï¼Œä¿å­˜ï¼ä¹‹åä¼šå‘ç° action åœ¨å°è¯•è¿è¡Œï¼Œç­‰å¾…ä¸åˆ°ä¸€åˆ†é’Ÿç»“æœå°±ä¼šå‡ºæ¥ï¼Œå˜æˆç»¿è‰²å°±è¯´æ˜æˆåŠŸå•¦ï¼\nè¿™æ—¶è·‘å»å…¬å¼€ä»“åº“ç…ç…çœ‹ï¼Œåº”è¯¥å·²ç»å¯ä»¥çœ‹åˆ°è‡ªåŠ¨å»ºäº†ä¸€ä¸ªåä¸º gh-pages çš„åˆ†æ”¯ï¼Œé‡Œé¢å‡ºç°äº†è®¸å¤šä¸œè¥¿ï¼Œæ­¤æ—¶æ‰“å¼€ä½ çš„åšå®¢åŸŸååº”è¯¥å·²ç»å¯ä»¥çœ‹åˆ°åšå®¢å†…å®¹å•¦ï¼\nå¦‚æœ github action æ²¡æˆåŠŸè·‘èµ·æ¥ä¹Ÿä¸è¦æ…Œï¼Œç‚¹è¿› deploy è¯¦ç»†çœ‹ä¸‹æŠ¥é”™ï¼Œä¸€èˆ¬éƒ½å¯ä»¥æ ¹æ®æŠ¥é”™å†…å®¹å‘ç°åŸå› ï¼Œå¯¹åº”å»è°ƒæ•´åå†è·‘å‡ éå³å¯ã€‚\nè‡ªå®šä¹‰åŸŸåæ³¨æ„äº‹é¡¹ åšå®¢æ ¹ç›®å½•ä¸‹çš„ config æ–‡ä»¶ä¸­ base url æ›´æ¢ä¸ºè‡ªå®šä¹‰åŸŸå ä¸ºè‡ªå®šä¹‰åŸŸåæ·»åŠ äº† CNAME è®°å½•ï¼ˆé¡¶çº§åŸŸåä¹Ÿå¯æ·»åŠ å››æ¡ A è®°å½•ï¼‰ï¼Œè¯¦è§ github å®˜æ–¹è¯´æ˜ï¼šManaging a custom domain for your GitHub Pages site éƒ¨ç½²æˆåŠŸåï¼Œè¿›å…¥å…¬å¼€ä»“åº“ settingsï¼Œpages é¡µé¢æ·»åŠ è‡ªå®šä¹‰åŸŸåï¼Œç­‰å¾… DNS æ£€éªŒæˆåŠŸ å¦‚æœä½¿ç”¨äº† CDNï¼ˆæ¯”å¦‚ cloudflareï¼‰ï¼Œgithub ä¸Šçš„å¼ºåˆ¶ https æŒ‰é’®å¯èƒ½ä¸èƒ½ç‚¹ï¼›cloudflare å…è´¹æä¾› https è¯ä¹¦ï¼Œå¦‚æœæ— æ³•æ­£å¸¸æ˜¾ç¤º httpsï¼Œå¯ä»¥å»ºç«‹å¼ºåˆ¶ https è§„åˆ™ ä¸é€‚ç”¨ CDN çš„æƒ…å†µä¸‹ï¼Œgithub å·²æ”¯æŒä¸ºè‡ªå®šä¹‰åŸŸååŠæ³• letâ€™s encrypt è¯ä¹¦ï¼Œç¨ç­‰ä¸€ä¼šå„¿å³å¯ç”Ÿæ•ˆ âœ§ éƒ¨ç½²å®Œæˆåç»­ç®¡ç†\n","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/test/","summary":"æ ¼å¼å‚è€ƒ GitHub Pages actionï¼Œå¯ä»¥æ ¹æ®è‡ªå·±éœ€è¦ï¼ŒæŒ‰ç…§è¯´æ˜æ–‡æ¡£ä¸Šçš„å»ºè®®å¯¹ä¸Šé¢çš„é…ç½®è¿›ä¸€æ­¥è°ƒæ•´ã€‚\næäº¤ commitï¼Œä¿å­˜ï¼ä¹‹åä¼šå‘ç° action åœ¨å°è¯•è¿è¡Œï¼Œç­‰å¾…ä¸åˆ°ä¸€åˆ†é’Ÿç»“æœå°±ä¼šå‡ºæ¥ï¼Œå˜æˆç»¿è‰²å°±è¯´æ˜æˆåŠŸå•¦ï¼\nè¿™æ—¶è·‘å»å…¬å¼€ä»“åº“ç…ç…çœ‹ï¼Œåº”è¯¥å·²ç»å¯ä»¥çœ‹åˆ°è‡ªåŠ¨å»ºäº†ä¸€ä¸ªåä¸º gh-pages çš„åˆ†æ”¯ï¼Œé‡Œé¢å‡ºç°äº†è®¸å¤šä¸œè¥¿ï¼Œæ­¤æ—¶æ‰“å¼€ä½ çš„åšå®¢åŸŸååº”è¯¥å·²ç»å¯ä»¥çœ‹åˆ°åšå®¢å†…å®¹å•¦ï¼\nå¦‚æœ github action æ²¡æˆåŠŸè·‘èµ·æ¥ä¹Ÿä¸è¦æ…Œï¼Œç‚¹è¿› deploy è¯¦ç»†çœ‹ä¸‹æŠ¥é”™ï¼Œä¸€èˆ¬éƒ½å¯ä»¥æ ¹æ®æŠ¥é”™å†…å®¹å‘ç°åŸå› ï¼Œå¯¹åº”å»è°ƒæ•´åå†è·‘å‡ éå³å¯ã€‚\nè‡ªå®šä¹‰åŸŸåæ³¨æ„äº‹é¡¹ åšå®¢æ ¹ç›®å½•ä¸‹çš„ config æ–‡ä»¶ä¸­ base url æ›´æ¢ä¸ºè‡ªå®šä¹‰åŸŸå ä¸ºè‡ªå®šä¹‰åŸŸåæ·»åŠ äº† CNAME è®°å½•ï¼ˆé¡¶çº§åŸŸåä¹Ÿå¯æ·»åŠ å››æ¡ A è®°å½•ï¼‰ï¼Œè¯¦è§ github å®˜æ–¹è¯´æ˜ï¼šManaging a custom domain for your GitHub Pages site éƒ¨ç½²æˆåŠŸåï¼Œè¿›å…¥å…¬å¼€ä»“åº“ settingsï¼Œpages é¡µé¢æ·»åŠ è‡ªå®šä¹‰åŸŸåï¼Œç­‰å¾… DNS æ£€éªŒæˆåŠŸ å¦‚æœä½¿ç”¨äº† CDNï¼ˆæ¯”å¦‚ cloudflareï¼‰ï¼Œgithub ä¸Šçš„å¼ºåˆ¶ https æŒ‰é’®å¯èƒ½ä¸èƒ½ç‚¹ï¼›cloudflare å…è´¹æä¾› https è¯ä¹¦ï¼Œå¦‚æœæ— æ³•æ­£å¸¸æ˜¾ç¤º httpsï¼Œå¯ä»¥å»ºç«‹å¼ºåˆ¶ https è§„åˆ™ ä¸é€‚ç”¨ CDN çš„æƒ…å†µä¸‹ï¼Œgithub å·²æ”¯æŒä¸ºè‡ªå®šä¹‰åŸŸååŠæ³• letâ€™s encrypt è¯ä¹¦ï¼Œç¨ç­‰ä¸€ä¼šå„¿å³å¯ç”Ÿæ•ˆ âœ§ éƒ¨ç½²å®Œæˆåç»­ç®¡ç†","title":"Test"},{"content":"This article is based on the Scroll project here.\nIntro In CSS, the conainer height is set to 0 dy default, because we don\u0026rsquo;t wanna show the container when we first load the page. We want to use the toggle button to control whether to show it or not. That\u0026rsquo;s also how we use toggle method. In CSS, we set the style of class .show-links to be height of 200, so when we add this class by using event listener, we will see the links. The height is static, so when we add or remove one link, our style wouldn\u0026rsquo;t seem as nice as it was before.\n So we use Element.getBoundingClientRect()! In this project, each link\u0026rsquo;s height is 50px, so we need to dynamically set the link-container\u0026rsquo;s height to be the sum of all links:\ntoggleBtn.addEventListener(\u0026#34;click\u0026#34;, function () { const containerHeight = linksContainer.getBoundingClientRect().height; const linksHeight = links.getBoundingClientRect().height; if (containerHeight === 0) { linksContainer.style.height = `${linksHeight}px`; } else { linksContainer.style.height = 0; } });  Note: Even if the links have their own heights, we wouldn\u0026rsquo;t see the links with the link-container\u0026rsquo;s height being set to 0.\n ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/dynamicnavbar/","summary":"This article is based on the Scroll project here.\nIntro In CSS, the conainer height is set to 0 dy default, because we don\u0026rsquo;t wanna show the container when we first load the page. We want to use the toggle button to control whether to show it or not. That\u0026rsquo;s also how we use toggle method. In CSS, we set the style of class .show-links to be height of 200, so when we add this class by using event listener, we will see the links.","title":"How to make dynamic navbar?"},{"content":"1. Remove Duplicates from Sorted Array Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array/\nMy first solution:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return null; let i = 0; let j= i+1; let k = 0; while (j \u0026lt; nums.length){ while(nums[i] === nums[j]){ nums.splice(j, 1); k ++; } i ++; j ++; } }; Refactored version:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return 0; let i = 0; for(let j=1; j\u0026lt;nums.length; j ++) { if(nums[i] !== nums[j]){ i ++; nums[i] = nums[j] } } return i+1; };  My first solution takes more space and time to run. At the first time, I misunderstood the intention of this question. It says what exists after the uique values doesn\u0026rsquo;t matter, while I thought I need to return a \u0026lsquo;clean\u0026rsquo; array with only unique values. That\u0026rsquo;s why I chose the method of \u0026lsquo;splice\u0026rsquo;.\n 2. Two Sum Link: https://leetcode.com/problems/two-sum/\nMy first Solution:\nvar twoSum = function(nums, target) { let result = []; for(let i=0; i\u0026lt;nums.length -1; i++) { for(let j = i+1; j \u0026lt; nums.length; j++) { if(nums[i] + nums[j] === target) { result[0] = i; result[1] = j; return result } } } }; Refactored version:\nvar twoSum = function(nums, target) { let map = new Map(); for(let i =0; i\u0026lt;nums.length; i++){ let diff = target - nums[i]; if (map.get(nums[i]) === undefined){ map.set(diff, i) } else { return [map.get(nums[i]),i] } } };  This one is pretty important. I know my first reaction of using a nested loop is definitely not a good idea. That will make time complexity 0(n^2). I searched other people\u0026rsquo;s solution, and find that this one need to take advantage of hash table. In this case, JS\u0026rsquo;s built-in hash table data structure - Map, comes in handy.\nUnder this question\u0026rsquo;s assumption,To get the target number, an item has only one number that can be added to it. So if we store the needed number and store them in a hash table, every time we get to next number, we can check if this number is in the hash table, and if not, we can calculate the second number and store that one in the map. Until at some point, we find the needed number in the map.\nThis way, the time complexity is O(n).\n 3. Roman to Integer Link: https://leetcode.com/problems/roman-to-integer/\nMy first solution:\nvar romanToInt = function(s) { const pattern = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; const rule = { V: \u0026#34;I\u0026#34;, X: \u0026#34;I\u0026#34;, L: \u0026#34;X\u0026#34;, C: \u0026#34;X\u0026#34;, D: \u0026#34;C\u0026#34;, M: \u0026#34;C\u0026#34; }; let currentSum = 0; let oneNumber = 0; let i = s.length - 1; let j = i - 1; while (j \u0026gt;= -1){ if(rule[s[i]] \u0026amp;\u0026amp; rule[s[i]] === s[j]){ oneNumber = pattern[s[i]] - pattern[s[j]] currentSum = currentSum + oneNumber i = i - 2; j = j - 2; } else { oneNumber = pattern[s[i]] currentSum = currentSum + oneNumber; i = i - 1; j = j - 1; } } return currentSum; }; Refactor version:\nvar romanToInt = function(s) { const pattern = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; let sum = 0; for(let i =0; i\u0026lt;s.length; i++){ let current = pattern[s[i]] let next = pattern[s[i+1]] if(current \u0026lt; next){ sum = sum - current } else { sum = sum + current } } return sum };  It\u0026rsquo;s more like a mathematical trick. For DXC, you needn\u0026rsquo;t treat XC as a unit. You can first subtract the X and then add the C if X is less than C.\nI think this solution is quite smart. Salute to whoever comes up with this solution!\n ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/algorithm1/","summary":"1. Remove Duplicates from Sorted Array Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array/\nMy first solution:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return null; let i = 0; let j= i+1; let k = 0; while (j \u0026lt; nums.length){ while(nums[i] === nums[j]){ nums.splice(j, 1); k ++; } i ++; j ++; } }; Refactored version:\nvar removeDuplicates = function(nums) { if(nums.length === 0) return 0; let i = 0; for(let j=1; j\u0026lt;nums.length; j ++) { if(nums[i] !","title":"Algorithm Practice 1"},{"content":" Here is the summary of some tricks from John Smilga\u0026rsquo;s JS projects. This post is depending on \u0026lsquo;Menu\u0026rsquo;.\n INTRO: While building simple project, it seems ok to hard-code some elements, like the buttons here. But in the real world, it would be better to dynamically render buttons due to the data we fetched from some database.    Use vanilla JS to load content when the DOM was first rendered.\nRemember the usage of window.addEnventListener and DOMContentLoaded.\nBy using these two methods, we can load the given data to the DOM through JS.\n//menu is an given array of a bunch of objects.  const sectionCenter = document.querySelector(\u0026#34;.section-center\u0026#34;); window.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function () { renderedMenu(menu) }); function renderedMenu(renderedMenu) { let displayMenu = renderedMenu.map(function (item) { return `Write the HTML that we need to render here, and concat them using join`; }); displayMenu = displayMenu.join(\u0026#34;\u0026#34;); //This display Menu is an array, so when we use method \u0026#34;join\u0026#34;, we can concatenate all the values.  //Note that if we don\u0026#39;t use an empty string, we will concat the returned values with comas among them.  sectionCenter.innerHTML = displayMenu; //sectionCenter is the parent element of all the menu items.  }   If we want to add buttons to filter all the items, we probably want to show different buttons due to different kinds, in this scenario, menu\u0026rsquo;s categories. Bacause the category\u0026rsquo;s amount will change some day, rendering some static buttons in the first place is not enough.\nfunction renderedBtn() { // First, fetch all the unique categories and put them into an array.  const categories = menu.reduce( function (values, item) { if (!values.includes(item.category)) { values.push(item.category); } return values; }, [\u0026#34;all\u0026#34;] ); // Second, build unique buttons for those categories.  const categoryBtn = categories .map(function (category) { return `\u0026lt;button class=\u0026#34;filter-btn\u0026#34; data-id=${category}\u0026gt;${category}\u0026lt;/button\u0026gt;`; }) .join(\u0026#34;\u0026#34;); btnContainer.innerHTML = categoryBtn; const btns = document.querySelectorAll(\u0026#34;.filter-btn\u0026#34;); // Third, for each button, add an event listener \u0026#39;click\u0026#39; to filter all the items.  btns.forEach(function (btn) { btn.addEventListener(\u0026#34;click\u0026#34;, function (e) { const id = e.currentTarget.dataset.id; const filteredItem = menu.filter(function (menuItem) { if (id === menuItem.category) { return menuItem; } }); if (id === \u0026#34;all\u0026#34;) { renderedMenu(menu); } else { renderedMenu(filteredItem); } }); }); }     Remember the use of JS method \u0026lsquo;reduce\u0026rsquo;, it receive a callback function. Its an pretty useful filter function.\n  Use dataset to add additional info to an element.\n  ","permalink":"https://epath2c.github.io/blogcabin.github.io/posts/dynamichtmlbyjs/","summary":"Here is the summary of some tricks from John Smilga\u0026rsquo;s JS projects. This post is depending on \u0026lsquo;Menu\u0026rsquo;.\n INTRO: While building simple project, it seems ok to hard-code some elements, like the buttons here. But in the real world, it would be better to dynamically render buttons due to the data we fetched from some database.    Use vanilla JS to load content when the DOM was first rendered.","title":"How to build dynamic HTML elements with vanilla JS?"}]